/*
	Created by Tech_dog (ebontrop@gmail.com) on 15-Dec-2025 at 22:19:37.870, UTC+4, Batumi, Monday;
	This is Ebo Pack OpenGL uniform variable related functions' loader interface implementation file;
*/
#include "gl_procs_uniform.h"
#include "gl_program.h"

#include "shared.preproc.h"
#include "shared.dbg.h"

using namespace ex_ui::draw::open_gl;
using namespace ex_ui::draw::open_gl::procs;
using namespace ex_ui::draw::open_gl::procs::vars;

#pragma region cls::proc::vars::CUniform{}

static _pc_sz uni_fun_names[] = { _T("glGetUniformLocation") };

enum class e_uni_fun_ndx : uint32_t {
	e_locate = 0x0
};

CUniform::CUniform (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

int32_t  CUniform::Locate (const uint32_t _prog_id, _pc_sz _p_name) {
	_prog_id; _p_name;
	/* Possible error code(s):
	GL_INVALID_OPERATION : '_prog_id' is not a program object;
	GL_INVALID_OPERATION : '_prog_id' has not been successfully linked;
	GL_INVALID_VALUE     : '_prog_id" is not a value generated by OpenGL;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	int32_t n_result = u_na_locate;
	CStringA cs_name(_p_name); cs_name.Trim();

	if (cs_name.IsEmpty()) {
		CBase::m_error <<__e_inv_arg = _T("#__e_inv_arg: '_p_name' is empty");
		return n_result;
	}

	pfn_Locate p_fun = reinterpret_cast<pfn_Locate>(CBase::Get(uni_fun_names[(uint32_t)e_uni_fun_ndx::e_locate]));
	if (nullptr == p_fun)
		return n_result;

	n_result = p_fun(_prog_id, CStringA(_p_name).GetString());
	const
	uint32_t u_err_code = CErr_ex().Get_code();
	switch ( u_err_code ) {
	case GL_INVALID_OPERATION : {
		if (false) {}
		else if (false == CProgram::Is_valid(_prog_id, CBase::m_error)) {}
		else CBase::m_error << (err_code)TErrCodes::eExecute::eState = TString().Format(_T("#__e_inv_state: prog (id = %u) is not linked"), _prog_id); // no link state is checked yet, in accordance with error code;
	} break;
	case GL_INVALID_VALUE : CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_prog: 'prog_id' (%u) is invalid"), _prog_id);
	default:
		if (!!u_err_code)
			CBase::m_error <<__e_fail = TString().Format(_T("#__e_undef: error code (%d)"),  u_err_code);
	}
	return  n_result;
}

err_code CUniform::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(uni_fun_names); i_++) {
		if (nullptr == CBase::Get(uni_fun_names[i_]))
			break;
	}

	return CBase::Error();
}

TUniformProcs&  ::__get_uni_procs (void) {
	static TUniformProcs procs;
	static bool b_loaded = false;

	if (false == b_loaded) {
		if (__failed(procs.Get_all())) {
			__trace_err_2(_T("%s;\n"), (_pc_sz) procs.Error().Print(TError::e_print::e_req)); }
		else
			b_loaded = true;
	}
	return procs;
}

#pragma endregion
#pragma region cls::proc::vars::CUni_value{}

static _pc_sz uni_val_fun_names[] = { _T("glGetUniformfv"), _T("glGetnUniformfv"), _T("glUniform4f"), _T("glUniform4fv") };

enum class e_uni_val_fun_ndx : uint32_t {
	e_get_3s = 0x0, e_get_3f_vec, e_set_4f_scalar, e_set_4f_vec
};

CUni_value::CUni_value (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

err_code CUni_value::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(uni_val_fun_names); i_++) {
		if (nullptr == CBase::Get(uni_val_fun_names[i_]))
			break;
	}

	return CBase::Error();
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniform.xhtml ;
err_code CUni_value::Get_3fs (const uint32_t _prog_id, const uint32_t _n_locate, t_uniform_3f& _arr_values) {
	_prog_id; _n_locate; _arr_values;
	/* Possible error code(s):
	GL_INVALID_VALUE     : '_prog_id' is not a value generated by OpenGL;
	GL_INVALID_OPERATION : '_prog_id' is not a program object;
	GL_INVALID_OPERATION : '_prog_id' has not been successfully linked;
	GL_INVALID_OPERATION : '_n_locate' does not correspond to a valid uniform variable location for the specified program object;
	GL_INVALID_OPERATION : '_arr_values' buffer size is not enough for storing the result data;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	if (3 != _arr_values.size())
		return CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_arr: '_arr_values' size is (%d), must be (3)"), _arr_values.size());

	pfn_Get_nfv p_fun = reinterpret_cast<pfn_Get_nfv>(CBase::Get(uni_val_fun_names[(uint32_t)e_uni_val_fun_ndx::e_get_3f_vec]));
	if (nullptr == p_fun)
		return CBase::Error();

	const uint32_t buffer_sz = sizeof(float) * static_cast<uint32_t>(_arr_values.size());

	p_fun(_prog_id, _n_locate, buffer_sz, _arr_values.data());
	const
	uint32_t u_err_code = CErr_ex().Get_code();
	switch ( u_err_code ) {
	case GL_INVALID_VALUE :
	case GL_INVALID_OPERATION : {
		if (false){}
		else if (false == program::CProgId::Is_valid(_prog_id, CBase::m_error)) { /* the error object is set by the procs being invoked;*/ }
		else if (false == program::CStatus::Is_linked(_prog_id, CBase::m_error)) { /* the error object is set by the procs being invoked;*/ }
		else
			CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_arg: '_n_locate' (%u) is not valid or 'buffer_sz' (%u) is small"), _prog_id, buffer_sz);
	} break;
	default:
		if (!!u_err_code)
			CBase::m_error <<__e_fail = TString().Format(_T("#__e_undef: error code 0x%04x (%d)"), u_err_code, u_err_code);
	}
	return CBase::Error();
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniform.xhtml ;
err_code CUni_value::Get_4fs (const uint32_t _prog_id, const uint32_t _n_locate, t_uniform_4f& _arr_values) {
	_prog_id; _n_locate; _arr_values;
	/* Possible error code(s):
	GL_INVALID_VALUE     : '_prog_id' is not a value generated by OpenGL;
	GL_INVALID_OPERATION : '_prog_id' is not a program object;
	GL_INVALID_OPERATION : '_prog_id' has not been successfully linked;
	GL_INVALID_OPERATION : '_n_locate' does not correspond to a valid uniform variable location for the specified program object;
	GL_INVALID_OPERATION : '_arr_values' buffer size is not enough for storing the result data;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	if (4 != _arr_values.size())
		return CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_arr: '_arr_values' size is (%d), must be (4)"), _arr_values.size());

	pfn_Get_nfv p_fun = reinterpret_cast<pfn_Get_nfv>(CBase::Get(uni_val_fun_names[(uint32_t)e_uni_val_fun_ndx::e_get_3f_vec]));
	if (nullptr == p_fun)
		return CBase::Error();

	const uint32_t buffer_sz = sizeof(float) * static_cast<uint32_t>(_arr_values.size());

	p_fun(_prog_id, _n_locate, buffer_sz, _arr_values.data());
	const
	uint32_t u_err_code = CErr_ex().Get_code();
	switch ( u_err_code ) {
	case GL_INVALID_VALUE :
	case GL_INVALID_OPERATION : {
		if (false){}
		else if (false == program::CProgId::Is_valid(_prog_id, CBase::m_error)) { /* the error object is set by the procs being invoked;*/ }
		else if (false == program::CStatus::Is_linked(_prog_id, CBase::m_error)) { /* the error object is set by the procs being invoked;*/ }
		else
			CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_arg: '_n_locate' (%u) is not valid or 'buffer_sz' (%u) is small"), _prog_id, buffer_sz);
	} break;
	default:
		if (!!u_err_code)
			CBase::m_error <<__e_fail = TString().Format(_T("#__e_undef: error code 0x%04x (%d)"), u_err_code, u_err_code);
	}
	return CBase::Error();
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform.xhtml ;
err_code CUni_value::Set_4fs (const int32_t _n_locate, const t_uniform_4f& _arr_values) {
	_n_locate; _arr_values;
	/* Possible error code(s):
	GL_INVALID_OPERATION : there is no current program object;
	GL_INVALID_OPERATION : '_n_locate' is an invalid uniform location for the current program object and location is not equal to -1;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	if (4 != _arr_values.size())
		return CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_arr: '_arr_values' size is (%d), must be (4)"), _arr_values.size());

	pfn_Set_4fs p_fun = reinterpret_cast<pfn_Set_4fs>(CBase::Get(uni_val_fun_names[(uint32_t)e_uni_val_fun_ndx::e_set_4f_scalar]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_n_locate, _arr_values.at(0), _arr_values.at(1), _arr_values.at(2), _arr_values.at(3));
	const
	uint32_t u_err_code = CErr_ex().Get_code();
	switch ( u_err_code ) {
	case GL_INVALID_OPERATION : {
		if (false) {}
		else if (0 == program::CStatus::GetActiveProg(CBase::m_error)) {
			if (false == CBase::Error()) // no error occurs in getting active program identifier;
				CBase::m_error << (err_code)TErrCodes::eExecute::eState = _T("#__e_inv_state: no program is active");
		}
		else // the error definition requires more details but for this version of the implementation generic error context is okay;
			CBase::m_error << (err_code)TErrCodes::eData::eInvalid = TString().Format(_T("#__e_inv_data: '_n_locate' (%d) is not valid"), _n_locate);

	} break;
	default:
		if (!!u_err_code)
			CBase::m_error <<__e_fail = TString().Format(_T("#__e_undef: error code (%d)"),  u_err_code);
	}
	return CBase::Error();
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform.xhtml ;
err_code CUni_value::Set_4fv (const int32_t _n_locate, const t_uniform_4f& _arr_values) {
	_n_locate; _arr_values;
	/* Possible error code(s):
	GL_INVALID_OPERATION : there is no current program object;
	GL_INVALID_OPERATION : the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command;
	GL_INVALID_OPERATION : '_n_locate' is an invalid uniform location for the current program object and location is not equal to -1;
	GL_INVALID_OPERATION : the count of elements in '_arr_values' is greater than 1 and the indicated uniform variable is not an array variable;
	GL_INVALID_VALUE     : the count of elements in '_arr_values' is less than 0 (zero); not expacted due to the input array has fixed size;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Set_4fv p_fun = reinterpret_cast<pfn_Set_4fv>(CBase::Get(uni_val_fun_names[(uint32_t)e_uni_val_fun_ndx::e_set_4f_scalar]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_n_locate, static_cast<uint32_t>(_arr_values.size()), _arr_values.data());
	const
	uint32_t u_err_code = CErr_ex().Get_code();
	switch ( u_err_code ) {
	case GL_INVALID_OPERATION : {
		if (false) {}
		else if (0 == program::CStatus::GetActiveProg(CBase::m_error)) {
			if (false == CBase::Error()) // no error occurs in getting active program identifier;
				CBase::m_error << (err_code)TErrCodes::eExecute::eState = _T("#__e_inv_state: no program is active");
		}
		else // the error definition requires more details but for this version of the implementation generic error context is okay;
			CBase::m_error << (err_code)TErrCodes::eData::eInvalid = TString().Format(_T("#__e_inv_data: '_n_locate' (%d) or number of array elements (4) does not match the shader code"), _n_locate);

	} break;
	default:
		if (!!u_err_code)
			CBase::m_error <<__e_fail = TString().Format(_T("#__e_undef: error code 0x%04x (%d)"), u_err_code, u_err_code);
	}
	return CBase::Error();
}

TUniValueProcs&  ::__get_uni_val_procs (void) {
	static TUniValueProcs procs;
	static bool b_loaded = false;

	if (false == b_loaded) {
		if (__failed(procs.Get_all())) {
			__trace_err_2(_T("%s;\n"), (_pc_sz) procs.Error().Print(TError::e_print::e_req)); }
		else
			b_loaded = true;
	}
	return procs;
}

#pragma endregion