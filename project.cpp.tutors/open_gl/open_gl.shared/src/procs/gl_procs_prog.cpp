/*
	Created by Tech_dog (ebontrop@gmail.com) on 06-Oct-2025 at 01:21:58.588, (UTC+4), Batumi, Monday;
	This is Ebo Pack OpenGL program functions' loader interface implementation file;
*/
#include "gl_procs_prog.h"
#include "gl_procs.h"
#include "gl_procs_shader.h"
#include"shared.preproc.h"

using namespace ex_ui::draw::open_gl;
using namespace ex_ui::draw::open_gl::procs;
using namespace ex_ui::draw::open_gl::procs::program;

#define GL_MAX_VERTEX_ATTRIBS 0x8869 // from glcorearb.h ;
#define __gl_curr_prog        0x8B8D // GL_CURRENT_PROGRAM ;

static _pc_sz attr_fun_names[] = {
	_T("glGetAttribLocation"), _T("glBindAttribLocation")
};
enum class e_attr_fun_ndx : uint32_t {
	e_get = 0x0, e_set = 0x1
};

CAttr:: CAttr (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml ;
int32_t  CAttr::GetIndex (const uint32_t _prog_id, _pc_sz _p_att_name) {
	_prog_id; _p_att_name;
	/* Possible errors, the one error code is for several specific cases:
		GL_INVALID_OPERATION : _prog_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : the object of _prog_id is not a program object ;
		GL_INVALID_OPERATION : the program of _prog_id has not been successfully linked ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	static const int32_t n_err_result = -1; // the same value is used in CAttr::CIndex;

	int32_t n_result = n_err_result;

	pfn_GetIndex  p_fun = reinterpret_cast<pfn_GetIndex>(CBase::Get(attr_fun_names[(uint32_t)e_attr_fun_ndx::e_get]));
	if (nullptr == p_fun)
		return n_result;

	CStringA cs_name(_p_att_name);

	n_result = p_fun(_prog_id, cs_name.GetString());

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION : {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' cannot be 0"));
			else if (false == CProg().IsProg(_prog_id)) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) refers to no program"), _prog_id);
			else CBase::m_error << (err_code) TErrCodes::eExecute::eOperate = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is not linked"), _prog_id);
		} break;
	default:;
	}
	return n_result;
}

err_code CAttr::SetIndex (const uint32_t _prog_id, _pc_sz _p_att_name, const uint32_t _u_ndx) {
	_prog_id; _p_att_name; _u_ndx;
	/* Possible error codes:
	GL_INVALID_VALUE     : '_u_ndx' is greater than or equal to GL_MAX_VERTEX_ATTRIBS;
	GL_INVALID_OPERATION : '_p_att_name' starts with the reserved prefix "gl_";
	GL_INVALID_VALUE     : '_prog_id' is not a value generated by OpenGL;
	GL_INVALID_OPERATION : '_prog_id' does not refer to a program object;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_SetIndex  p_fun = reinterpret_cast<pfn_SetIndex>(CBase::Get(attr_fun_names[(uint32_t)e_attr_fun_ndx::e_set]));
	if (nullptr == p_fun)
		return CBase::Error();

	CStringA cs_name(_p_att_name);

	p_fun(_prog_id, _u_ndx, cs_name.GetString());

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION : {
			if (false == CProg().IsProg(_prog_id)) CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) refers to no program"), _prog_id);
			else CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: '_p_att_name' (%s) is invalid"), _p_att_name);
		} break;
	case GL_INVALID_VALUE : {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) has invalid value"), _prog_id);
			else if (GL_MAX_VERTEX_ATTRIBS <= _u_ndx) CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_u_ndx' (%u) is out of range"), _u_ndx);
			else CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid"), _prog_id);
		} break;
	default:;
	};

	return CBase::Error();
}

/////////////////////////////////////////////////////////////////////////////

static _pc_sz prog_fun_names[] = {
	_T("glCreateProgram"), _T("glDeleteProgram"), _T("glGetProgramInfoLog"), _T("glGetProgramiv"),
	_T("glIsProgram"), _T("glUseProgram"), _T("glValidateProgram"),
};

enum class e_prog_fun_ndx : uint32_t {
	e_create = 0x0, e_delete = 0x1, e_info_log = 0x2, e_params = 0x3, e_is_prog = 0x4, e_use = 0x5, e_valid = 0x6,
};

CProg:: CProg (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

#define __gl_lnk_status    0x8B82 // GL_LINK_STATUS ;

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml ;
uint32_t CProg::Create (void){
	// the returned result value is zero (0) if an error occurs creating the program object ;
	// possibly the error code may be generic GL_OUT_OF_MEMORY ;
	CBase::m_error << __METHOD__ << __s_ok;

	static const uint32_t n_err_result = 0;

	uint32_t n_result = n_err_result;

	pfn_Create  p_fun = reinterpret_cast<pfn_Create>(CBase::Get(prog_fun_names[(uint32_t)e_prog_fun_ndx::e_create]));
	if (nullptr == p_fun)
		return n_result;

	n_result = p_fun();

	if (0 == n_result) {
		switch (CErr_ex().Get_code()) {
		case GL_OUT_OF_MEMORY: CBase::m_error << __e_no_memory = _T("#__e_no_mem: generic error;"); break;
		default:
			CBase::m_error << (err_code) TErrCodes::eExecute::eInternal = _T("#__e_inv_oper: a program cannot be created");
		}
	}
	return n_result;
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml ;
err_code CProg::Delete (const uint32_t _prog_id){
	_prog_id;
	// GL_INVALID_VALUE : _prog_id is not a value generated by OpenGL ;
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Delete p_fun = reinterpret_cast<pfn_Delete>(CBase::Get(prog_fun_names[(uint32_t)e_prog_fun_ndx::e_delete]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_VALUE: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is not valid;"), _prog_id);
	default:;
	}
	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml ;
err_code CProg::InfoLog (const uint32_t _prog_id, const int32_t _buf_size, int32_t* _log_len, char* _p_log){
	_prog_id; _buf_size; _log_len; _p_log;
	/* Possible errors:
		GL_INVALID_VALUE     : _prog_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _prog_id is not an identifier of program object ;
		GL_INVALID_VALUE     : _buf_size is less than 0 ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_InfoLog p_fun = reinterpret_cast<pfn_InfoLog>(CBase::Get(prog_fun_names[(uint32_t)e_prog_fun_ndx::e_info_log]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _buf_size, _log_len, _p_log);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) refers to no program object"), _prog_id); break;
	case GL_INVALID_VALUE: {
			if (0 > _buf_size)
			     CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_buf_size' (%d) is negative;"), _buf_size);
			else CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
		} break;
	default:;
	}

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgram.xhtml ;
bool     CProg::IsProg  (const uint32_t _prog_id) {
	_prog_id;
	// no error is thrown/generated by this function;
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_IsProg p_fun = reinterpret_cast<pfn_IsProg>(CBase::Get(prog_fun_names[(uint32_t)e_prog_fun_ndx::e_is_prog]));
	if (nullptr == p_fun)
		return false;
	else
		return !!p_fun(_prog_id);
}
// https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glGetProgramiv.xml ;
err_code CProg::Params  (const uint32_t _prog_id, const uint32_t _param_id, int32_t* _p_params){
	_prog_id; _param_id; _p_params;
	/* Possible errors:
		GL_INVALID_ENUM      : _param_id is not an accepted value ;
		GL_INVALID_VALUE     : _prog_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _prog_id is not the identifier of a program object ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Params p_fun = reinterpret_cast<pfn_Params>(CBase::Get(prog_fun_names[(uint32_t)e_prog_fun_ndx::e_params]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _param_id, _p_params);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_ENUM: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_enum: '_param_id' (%u) is not accepted;"), _param_id); break;
	case GL_INVALID_OPERATION: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) refers to no program;"), _prog_id); break;
	case GL_INVALID_VALUE: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id); break;
	default:;
	}

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgram.xhtml ;
err_code CProg::Use (const uint32_t _prog_id){
	_prog_id;
	/* Possible errors:
		GL_INVALID_VALUE     : '_prog_id' is neither 0 nor a value generated by OpenGL ;
		GL_INVALID_OPERATION : '_prog_id' is not the identifier of a program object ;
		GL_INVALID_OPERATION : the program object of '_prog_id' could not be made part of current state ;
		GL_INVALID_OPERATION : transform feedback mode is active ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Use p_fun = reinterpret_cast<pfn_Use>(CBase::Get(prog_fun_names[(uint32_t)e_prog_fun_ndx::e_use]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_VALUE: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id); break;
	case GL_INVALID_OPERATION : {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' cannot be 0"));
			else if (false == this->IsProg(_prog_id)) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) refers to no program"), _prog_id);
			else CBase::m_error << (err_code) TErrCodes::eExecute::eOperate
				= TString().Format(_T("#__e_inv_oper: the program of '_prog_id' (%u) is out of current state or feedback mode is active"), _prog_id);
		} break;
	default:;
	}

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml ;
err_code CProg::Validate (const uint32_t _prog_id){
	_prog_id;
	/* Possible errors:
		GL_INVALID_VALUE     : _prog_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _prog_id is not the identifier of a program object ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Validate p_fun = reinterpret_cast<pfn_Validate>(CBase::Get(prog_fun_names[(uint32_t)e_prog_fun_ndx::e_valid]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION : CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) refers to no program;"), _prog_id); break;
	case GL_INVALID_VALUE : CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id); break;
	default:;
	}

	return CBase::Error();
}

err_code CProg::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(prog_fun_names); i_++) {
		if (nullptr == CBase::Get(prog_fun_names[i_]))
			break;
	}

	return CBase::Error();
}

/////////////////////////////////////////////////////////////////////////////

static _pc_sz $_fun_names[] = { _T("glAttachShader"), _T("glDetachShader"), _T("glGetAttachedShaders") };
enum class  e_$_fun_ndx : uint32_t {
	e_attach = 0x0, e_detach = 0x1, e_attached = 0x2
};

CShaders:: CShaders (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml ;
err_code CShaders::Attach (const uint32_t _prog_id, const uint32_t _shader_id) {
	_prog_id; _shader_id;
	/* Possible errors:
		GL_INVALID_VALUE : either '_prog_id' or '_shader_id' is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : '_prog_id' is not an identifier of program object ;
		GL_INVALID_OPERATION : '_shader_id' is not an identifier of shader object ;
		GL_INVALID_OPERATION : the shader of '_shader_id' identifier is already attached to the program object of '_prog_id' ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Attach p_fun = reinterpret_cast<pfn_Attach>(CBase::Get($_fun_names[(uint32_t)e_$_fun_ndx::e_attach]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _shader_id);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION:
	case GL_INVALID_VALUE: {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 == _shader_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_shader_id' (%u) is invalid;"), _shader_id);
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog)) // ToDo: this must be moved to CProg implementation, but not used here like this;
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
			}
			else if (0 != _shader_id) {
				CShader shader;
				if (false == shader.Is_valid(_shader_id))
					CBase::m_error = shader.Error();
				else
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_shader_id' (%u) is attached;"), _shader_id);
			}
		} break;
	default:;
	}
	return CBase::Error();
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml ;
// *important* the signed integer data types is changed to unsigned one intentionally;
err_code CShaders::Attached (const uint32_t _prog_id, const uint32_t _u_max_cnt, uint32_t* _p_count, uint32_t* _p_shaders) {
	_prog_id; _u_max_cnt; _p_count; _p_shaders;
	/* Possible error coders:
		GL_INVALID_VALUE     : '_prog_id' is not a value generated by OpenGL;
		GL_INVALID_OPERATION : '_prog_id' is not a program object;
		GL_INVALID_VALUE     : '_u_max_cnt' is less than 0 (zero); actually it is not possible taking into account the changed data type to unsigned one;
	*/
	CBase::m_error << __METHOD__ << __s_ok;
	if (nullptr == _p_count) return CBase::m_error <<__e_pointer = _T("'_p_count' is nullptr");
	if (nullptr == _p_shaders) return CBase::m_error <<__e_pointer = _T("'_p_shaders' is nullptr");

	pfn_Attached p_fun = reinterpret_cast<pfn_Attached>(CBase::Get($_fun_names[(uint32_t)e_$_fun_ndx::e_attach]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _u_max_cnt, _p_count, _p_shaders);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION:
	case GL_INVALID_VALUE: {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 == _u_max_cnt) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_u_max_cnt' (%u) is invalid;"), _u_max_cnt); // ToDo: not sure that this is correct regarding the 0 value;
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog)) // ToDo: this must be moved to CProg implementation, but not used here like this;
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
			}
		} break;
	default:;
	}

	return CBase::Error();
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDetachShader.xhtml
err_code CShaders::Detach (const uint32_t _prog_id, const uint32_t _shader_id) {
	_prog_id; _shader_id;
	/* Possible error codes:
	GL_INVALID_VALUE     : either '_prog_id' or '_shader_id' is a value that was not generated by OpenGL;
	GL_INVALID_OPERATION : '_prog_id' does not refer to a program object';
	GL_INVALID_OPERATION : '_shader_id' does not refer to a shader object;
	GL_INVALID_OPERATION : a shader object of '_shader_id' is not attached to a program of '_prog_id';
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Detach p_fun = reinterpret_cast<pfn_Detach>(CBase::Get($_fun_names[(uint32_t)e_$_fun_ndx::e_detach]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _shader_id);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION :
	case GL_INVALID_VALUE : {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 == _shader_id) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_val: '_shader_id' (%u) is invalid;"), _shader_id);
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog))
					CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
			}
			else if (0 != _shader_id) {
				CShader shader;
				if (false == shader.Is_valid(_shader_id))
					CBase::m_error = shader.Error();
				else
					CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_shader_id' (%u) is attached;"), _shader_id);
			}
			else {
				CBase::m_error <<(err_code)TErrCodes::eExecute::eOperate = TString().Format(_T("#__e_inv_oper: '_shader_id' (%u) is not attached to '_prog_id' (%u);"), _shader_id, _prog_id);
			}
		} break;
	default:;
	}
	return CBase::Error();
}