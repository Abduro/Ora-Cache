/*
	Created by Tech_dog (ebontrop@gmail.com) on 09-Oct-2025 at 16:26:54.639, (UTC+4), Batumi, Thursday;
	This is Ebo Pack OpenGL shader functions' loader interface implementation file;
*/
#include "gl_procs_shader.h"
#include "gl_shd_type.h"
#include "shared.dbg.h"
#include "shared.preproc.h"

using namespace ex_ui::draw::open_gl;
using namespace ex_ui::draw::open_gl::procs;

#define GL_COMPILE_STATUS        0x8B81 // from glcorearb.h ;
#define GL_INFO_LOG_LENGTH       0x8B84 // from glcorearb.h ;
#define GL_SHADER_SOURCE_LENGTH  0x8B88 // from glcorearb.h ;

#define __err_no_support DXGI_ERROR_UNSUPPORTED

static _pc_sz shader_fun_names[] = {
	  _T("glCreateShader"),  _T("glDeleteShader"),  _T("glGetShaderInfoLog"),  _T("glGetShaderiv"), _T("glIsShader"), _T("glShaderSource")
};
enum class e_shader_fun_ndx : uint32_t {
	e_create = 0, e_delete = 1, e_infolog = 2, e_params = 3, e_is_shader = 4, e_source = 5,
};

CShader:: CShader (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml ;
uint32_t  CShader::Create  (const uint32_t _u_type) {
	_u_type;
	/* Possible errors:
		the retult is 0 : an error occurs creating the shader object; a call to glGetShaderInfoLog() does nothing because shader id is not set ;
		GL_INVALID_ENUM : is not an accepted value ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	static const uint32_t n_err_result = 0;

	uint32_t n_result = n_err_result;

	pfn_Create p_fun = reinterpret_cast<pfn_Create>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_create]));
	if (nullptr == p_fun) // the error object is set by parent class 'CBase';
		return n_result;

	n_result = p_fun(_u_type);

	if (0 == n_result) {
		switch (CErr_ex().Get_last(false)) {
		case GL_INVALID_ENUM: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: '_u_type' (%u) is invalid"), _u_type); break;
		default:
			CBase::m_error << __e_fail = TString().Format(_T("#__e_int_err: creating shader of type '%s' failed"), (_pc_sz)shader::CType::To_str(_u_type));
		}
	}

	return n_result;
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml ;
err_code  CShader::Delete  (const uint32_t _shader_id) {
	_shader_id;
	// GL_INVALID_VALUE : _shader_id is not a value generated by OpenGL ;
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Delete p_fun = reinterpret_cast<pfn_Delete>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_delete]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id);

	switch (CErr_ex().Get_last(false)) {
	case GL_INVALID_VALUE: CBase::m_error << __e_inv_arg = TString().Format(_T("'_shader_id' (%u) is invalid"), _shader_id); break;
	default:; // no error;
	}

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml ;
err_code  CShader::InfoLog (uint32_t _shader_id, int32_t _n_max_length, int32_t* _p_log_len, char* _p_log) {
	_shader_id; _n_max_length; _p_log_len; _p_log;
	/* Possible errors:
		GL_INVALID_VALUE     : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
		GL_INVALID_VALUE     : _n_max_length is less than 0 ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_InfoLog p_fun = reinterpret_cast<pfn_InfoLog>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_infolog]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id, _n_max_length, _p_log_len, _p_log);

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glIsShader.xml ;
bool   CShader::Is_valid  (uint32_t _shader_id) {
	_shader_id;
	// no error is generated if _shader_id is not a valid shader object identifier ;
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_IsValid p_fun = reinterpret_cast<pfn_IsValid>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_is_shader]));
	if (nullptr == p_fun) {
		return false;
	}

	const uint32_t b_result = !!p_fun(_shader_id);

	return b_result;
}
// https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glGetShaderiv.xml ;
err_code  CShader::Params  (uint32_t _shader_id, uint32_t _param_type, int32_t* _p_params) {
	_shader_id; _param_type; _p_params;
	CBase::m_error << __METHOD__ << __s_ok;
	/* Possible errors:
		GL_INVALID_ENUM : _param_type is not an accepted value ;
		GL_INVALID_VALUE : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _param_type is GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, or GL_SHADER_SOURCE_LENGTH, but a shader compiler is not supported ;
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
	*/
	pfn_Params p_fun = reinterpret_cast<pfn_Params>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_params]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id, _param_type, _p_params);
	
	switch (CError_ex().Get_last(false)) {
	case GL_INVALID_ENUM : { CBase::m_error << (err_code)TErrCodes::eData::eNotFound = TString().Format(_T("_param_type (%u) is invalid"), _param_type); } break;
	case GL_INVALID_VALUE : { CBase::m_error << (err_code)TErrCodes::eData::eInvalid = TString().Format(_T("_shader_id (%u) is invalid"), _shader_id); } break;
	case GL_INVALID_OPERATION : {
		if (false) {}
		else if (GL_COMPILE_STATUS == _param_type) { CBase::m_error << __err_no_support = TString().Format(_T("No support for compiler: __compile_status (0x%04%x) #na"), _param_type); }
		else if (GL_INFO_LOG_LENGTH == _param_type) { CBase::m_error << __err_no_support = TString().Format(_T("No support for compiler: __info_log_len (0x%04%x) #na"), _param_type); }
		else if (GL_SHADER_SOURCE_LENGTH == _param_type) { CBase::m_error << __err_no_support = TString().Format(_T("No support for compiler: __shader_src_len (0x%04%x) #na"), _param_type); }
		else {
			CBase::m_error << __e_inv_arg = TString().Format(_T("_shader_id (%u) refers to no shader"), _shader_id); } break;
		}
	default:;
	}

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml ;
err_code  CShader::Source  (uint32_t _shader_id, int32_t _n_count, const char** const _p_string, const int32_t* _p_length) {
	_shader_id; _n_count; _p_string; _p_length;
	/* Possible errors:
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
		GL_INVALID_VALUE     : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_VALUE     : _n_count is less than 0 ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Source p_fun = reinterpret_cast<pfn_Source>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_source]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id, _n_count, _p_string, _p_length);

	switch (CErr_ex().Get_last(false)){
	case GL_INVALID_OPERATION: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: '_shader_id'(%u) refers to not shader object;"), _shader_id); break;
	case GL_INVALID_VALUE: {
			if (0 > _n_count)
			     CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_arg: '_n_count'(%d) cannot be negative;"), _n_count);
			else CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_arg: '_shader_id'(%u) is invalid;"), _shader_id);
		} break;
	default:;
	}
	return CBase::Error();
}

err_code CShader::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(shader_fun_names); i_++) {
		if (nullptr == CBase::Get(shader_fun_names[i_]))
			break;
	}

	return CBase::Error();
}

TShaderProcs&  ::__get_$_procs (void) {
	static TShaderProcs procs;
	static bool b_loaded = false;
	if (false == b_loaded) {
		if (__failed(procs.Get_all())) {
		    __trace_err_2(_T("%s;\n"), (_pc_sz) procs.Error().Print(TError::e_print::e_req)); }
		else
		    b_loaded = true;
	}
	return procs;
}