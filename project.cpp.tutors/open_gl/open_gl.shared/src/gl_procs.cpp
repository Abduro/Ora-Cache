/*
	Created by Tech_dog (ebontrop@gmail.com) on 06-Sep-2025 at 13:13:58.859, UTC+4, Batumi, Saturday;
	This is Ebo Pack OpenGL tutorials' procedures loader wrapper interface implementation file; 
*/
#include "gl_procs.h"
#include "shared.preproc.h"

using namespace ex_ui::draw::open_gl;
using namespace ex_ui::draw::open_gl::procs;

namespace ex_ui { namespace draw { namespace open_gl { namespace _impl_1 { void __warning_lnk_4006 (void) {}}}}}

#define GL_SHADER_COMPILER 0x8dfa // from glcorearb.h ;

static _pc_sz cmpl_fun_names[] = { _T("glCompileShader"), _T("glReleaseShaderCompiler") };

CCompiler:: CCompiler (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml ;
err_code  CCompiler::Compile (uint32_t _shader_id) {
	_shader_id;
	/* Possible errors:
		GL_INVALID_VALUE     : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Compile p_fun = reinterpret_cast<pfn_Compile>(CBase::Get(cmpl_fun_names[0]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_VALUE:  CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: _shader_id (%u) is not valid;"), _shader_id); break;
	case GL_INVALID_OPERATION:  CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: _shader_id (%u) refers to not shader;"), _shader_id); break;
	default:;
	}

	return CBase::Error();
}

bool CCompiler::Is_supported (void) const {
	CBase::m_error <<__METHOD__<<__s_ok;

	bool b_result = false;

	CParam param;
	b_result = param.GetBool(GL_SHADER_COMPILER);

	if (param.Error().Is()) {
		if (GL_INVALID_ENUM == CError_ex().Get_code())
			CBase::m_error << __e_inv_arg = TString().Format(_T("The param id (0x%04x) is undefined"), GL_SHADER_COMPILER);
		else
			CBase::m_error = param.Error();
	}
	return b_result;
}

err_code CCompiler::Release (void) {
	CBase::m_error <<__METHOD__<<__s_ok;

	pfn_Release p_fun = reinterpret_cast<pfn_Release>(CBase::Get(cmpl_fun_names[1]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun();

	return CBase::Error();
}

err_code CCompiler::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(cmpl_fun_names); i_++) {
		if (nullptr == CBase::Get(cmpl_fun_names[i_]))
			break;
	}

	return CBase::Error();
}

/////////////////////////////////////////////////////////////////////////////

#define __gl_curr_prog 0x8B8D // GL_CURRENT_PROGRAM ;

static _pc_sz lnk_fun_names[] = { _T("glLinkProgram") };
enum class  e_lnk_fun_ndx : uint32_t {
	e_link = 0x0,
};

CLinker:: CLinker (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml ;
err_code CLinker::Link (const uint32_t _prog_id){
	_prog_id;
	/* Possible errors:
		GL_INVALID_VALUE     : _prog_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : the object of _prog_id is not a program one ;
		GL_INVALID_OPERATION : _prog_id is identifier of the currently active program object and transform feedback mode is active ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Link p_fun = reinterpret_cast<pfn_Link>(CBase::Get(lnk_fun_names[(uint32_t)e_lnk_fun_ndx::e_link]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_OPERATION :
	case GL_INVALID_VALUE : {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog))
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
				else
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) >> transform is active;"), _prog_id);
			}
		} break;
	default:;
	}
	return CBase::Error();
}

/////////////////////////////////////////////////////////////////////////////

static _pc_sz param_fun_names[] = {
	_T("glGetBooleanv"), _T("glGetFloatv"), _T("glGetIntegerv")
};

CParam:: CParam (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}
// https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glGet.xml ;
bool    CParam::GetBool (const uint32_t _u_param_id) {
	_u_param_id;
	// GL_INVALID_ENUM : _u_param_id has unknown value;
	CBase::m_error << __METHOD__ << __s_ok;

	uint32_t u_result = 0;

	pfn_GetBool p_fun = reinterpret_cast<pfn_GetBool>(CBase::Get(param_fun_names[0]));
	if (nullptr == p_fun) { // the error is set by parent class;
		return !!u_result;
	}

	p_fun(_u_param_id, &u_result);

	return !!u_result;
}

float   CParam::GetFloat (const uint32_t _u_param_id) {
	_u_param_id;
	// GL_INVALID_ENUM : _u_param_id has unknown value;
	CBase::m_error << __METHOD__ << __s_ok;

	float f_result = 0.0f;

	pfn_GetFloat p_fun = reinterpret_cast<pfn_GetFloat>(CBase::Get(param_fun_names[1]));
	if (nullptr == p_fun) {
		return f_result;
	}

	p_fun(_u_param_id, &f_result);

	return f_result;
}
// https://learn.microsoft.com/en-us/windows/win32/opengl/glgetintegerv ;
int32_t CParam::GetInt (const uint32_t _u_param_id) {
	_u_param_id;
	// GL_INVALID_ENUM : _u_param_id has unknown value;
	CBase::m_error << __METHOD__ << __s_ok;

	int32_t n_result = 0;

	pfn_GetInt p_fun = reinterpret_cast<pfn_GetInt>(CBase::Get(param_fun_names[2]));
	if (nullptr == p_fun) {
		return n_result;
	}

	p_fun(_u_param_id, &n_result);

	switch (CErr_ex().Get_code()) {
	case GL_INVALID_ENUM: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_enum: '_u_param_id' (%u) is invalid;"), _u_param_id);
	default:;
	}

	return n_result;
}