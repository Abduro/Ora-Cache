/*
	Created by Tech_dog (ebontrop@gmail.com) on 06-Sep-2025 at 13:13:58.859, UTC+4, Batumi, Saturday;
	This is Ebo Pack OpenGL tutorials' procedures loader wrapper interface implementation file; 
*/
#include "gl_procs.h"
#include "shared.preproc.h"

using namespace ex_ui::draw::open_gl::procs;

namespace ex_ui { namespace draw { namespace open_gl { namespace _impl_1 { void __warning_lnk_4006 (void) {}}}}}

#define GL_SHADER_COMPILER 0x8dfa // from glcorearb.h ;

static _pc_sz cmpl_fun_names[] = { _T("glCompileShader"), _T("glReleaseShaderCompiler") };

CCompiler:: CCompiler (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml ;
err_code  CCompiler::Compile (uint32_t _shader_id) {
	_shader_id;
	/* Possible errors:
		GL_INVALID_VALUE     : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Compile p_fun = reinterpret_cast<pfn_Compile>(CBase::Get(cmpl_fun_names[0]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id);

	switch (CErr_ex().Get_last(false)) {
	case GL_INVALID_VALUE:  CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_val: _shader_id (%u) is not valid;"), _shader_id); break;
	case GL_INVALID_OPERATION:  CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: _shader_id (%u) refers to not shader;"), _shader_id); break;
	default:;
	}

	return CBase::Error();
}

bool CCompiler::Is_supported (void) const {
	CBase::m_error <<__METHOD__<<__s_ok;

	bool b_result = false;

	CParam param;
	b_result = param.GetBool(GL_SHADER_COMPILER);

	if (param.Error().Is()) {
		if (GL_INVALID_ENUM == CError_ex().Get_last(false))
			CBase::m_error << __e_inv_arg = TString().Format(_T("The param id (0x%04x) is undefined"), GL_SHADER_COMPILER);
		else
			CBase::m_error = param.Error();
	}
	return b_result;
}

err_code CCompiler::Release (void) {
	CBase::m_error <<__METHOD__<<__s_ok;

	pfn_Release p_fun = reinterpret_cast<pfn_Release>(CBase::Get(cmpl_fun_names[1]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun();

	return CBase::Error();
}

err_code CCompiler::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(cmpl_fun_names); i_++) {
		if (nullptr == CBase::Get(cmpl_fun_names[i_]))
			break;
	}

	return CBase::Error();
}

/////////////////////////////////////////////////////////////////////////////

#define __gl_curr_prog 0x8B8D // GL_CURRENT_PROGRAM ;

static _pc_sz lnk_fun_names[] = { _T("glAttachShader"), _T("glDetachShader"), _T("glGetAttachedShaders"), _T("glLinkProgram") };
enum class  e_lnk_fun_ndx : uint32_t {
	e_attach = 0x0, e_detach = 0x1, e_attached = 0x2, e_link = 0x3,
};

CLinker:: CLinker (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml ;
err_code CLinker::Attach (const uint32_t _prog_id, const uint32_t _shader_id) {
	_prog_id; _shader_id;
	/* Possible errors:
		GL_INVALID_VALUE : either '_prog_id' or '_shader_id' is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : '_prog_id' is not an identifier of program object ;
		GL_INVALID_OPERATION : '_shader_id' is not an identifier of shader object ;
		GL_INVALID_OPERATION : the shader of '_shader_id' identifier is already attached to the program object of '_prog_id' ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Attach p_fun = reinterpret_cast<pfn_Attach>(CBase::Get(lnk_fun_names[(uint32_t)e_lnk_fun_ndx::e_attach]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _shader_id);

	switch (CErr_ex().Get_last(false)) {
	case GL_INVALID_OPERATION:
	case GL_INVALID_VALUE: {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 == _shader_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_shader_id' (%u) is invalid;"), _shader_id);
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog)) // ToDo: this must be moved to CProg implementation, but not used here like this;
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
			}
			else if (0 != _shader_id) {
				CShader shader;
				if (false == shader.Is_valid(_shader_id))
					CBase::m_error = shader.Error();
				else
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_shader_id' (%u) is attached;"), _shader_id);
			}
		} break;
	default:;
	}
	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml ;
// *important* the signed integer data types is changed to unsigned one intentionally;
err_code CLinker::Attached (const uint32_t _prog_id, const uint32_t _u_max_cnt, uint32_t* _p_count, uint32_t* _p_shaders) {
	_prog_id; _u_max_cnt; _p_count; _p_shaders;
	/* Possible error coders:
		GL_INVALID_VALUE     : '_prog_id' is not a value generated by OpenGL;
		GL_INVALID_OPERATION : '_prog_id' is not a program object;
		GL_INVALID_VALUE     : '_u_max_cnt' is less than 0 (zero); actually it is not possible taking into account the changed data type to unsigned one;
	*/
	CBase::m_error << __METHOD__ << __s_ok;
	if (nullptr == _p_count) return CBase::m_error <<__e_pointer = _T("'_p_count' is nullptr");
	if (nullptr == _p_shaders) return CBase::m_error <<__e_pointer = _T("'_p_shaders' is nullptr");

	pfn_Attached p_fun = reinterpret_cast<pfn_Attached>(CBase::Get(lnk_fun_names[(uint32_t)e_lnk_fun_ndx::e_attach]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _u_max_cnt, _p_count, _p_shaders);

	switch (CErr_ex().Get_last(false)) {
	case GL_INVALID_OPERATION:
	case GL_INVALID_VALUE: {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 == _u_max_cnt) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_u_max_cnt' (%u) is invalid;"), _u_max_cnt); // ToDo: not sure that this is correct regarding the 0 value;
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog)) // ToDo: this must be moved to CProg implementation, but not used here like this;
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
			}
		} break;
	default:;
	}

	return CBase::Error();
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDetachShader.xhtml
err_code CLinker::Detach (const uint32_t _prog_id, const uint32_t _shader_id) {
	_prog_id; _shader_id;
	/* Possible error codes:
	GL_INVALID_VALUE     : either '_prog_id' or '_shader_id' is a value that was not generated by OpenGL;
	GL_INVALID_OPERATION : '_prog_id' does not refer to a program object';
	GL_INVALID_OPERATION : '_shader_id' does not refer to a shader object;
	GL_INVALID_OPERATION : a shader object of '_shader_id' is not attached to a program of '_prog_id';
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Detach p_fun = reinterpret_cast<pfn_Detach>(CBase::Get(lnk_fun_names[(uint32_t)e_lnk_fun_ndx::e_detach]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id, _shader_id);

	switch (CErr_ex().Get_last(false)) {
	case GL_INVALID_OPERATION :
	case GL_INVALID_VALUE : {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 == _shader_id) CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_val: '_shader_id' (%u) is invalid;"), _shader_id);
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog))
					CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
			}
			else if (0 != _shader_id) {
				CShader shader;
				if (false == shader.Is_valid(_shader_id))
					CBase::m_error = shader.Error();
				else
					CBase::m_error <<__e_inv_arg = TString().Format(_T("#__e_inv_oper: '_shader_id' (%u) is attached;"), _shader_id);
			}
			else {
				CBase::m_error <<(err_code)TErrCodes::eExecute::eOperate = TString().Format(_T("#__e_inv_oper: '_shader_id' (%u) is not attached to '_prog_id' (%u);"), _shader_id, _prog_id);
			}
		} break;
	default:;
	}
	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml ;
err_code CLinker::Link (const uint32_t _prog_id){
	_prog_id;
	/* Possible errors:
		GL_INVALID_VALUE     : _prog_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : the object of _prog_id is not a program one ;
		GL_INVALID_OPERATION : _prog_id is identifier of the currently active program object and transform feedback mode is active ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Link p_fun = reinterpret_cast<pfn_Link>(CBase::Get(lnk_fun_names[(uint32_t)e_lnk_fun_ndx::e_link]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_prog_id);

	switch (CErr_ex().Get_last(false)) {
	case GL_INVALID_OPERATION :
	case GL_INVALID_VALUE : {
			if (false) {}
			else if (0 == _prog_id) CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_val: '_prog_id' (%u) is invalid;"), _prog_id);
			else if (0 != _prog_id) {
				if (static_cast<int32_t>(_prog_id) != CParam().GetInt(__gl_curr_prog))
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) is invalid;"), _prog_id);
				else
					CBase::m_error <<__e_inv_arg << TString().Format(_T("#__e_inv_oper: '_prog_id' (%u) >> transform is active;"), _prog_id);
			}
		} break;
	default:;
	}
	return CBase::Error();
}

err_code CLinker::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(lnk_fun_names); i_++) {
		if (nullptr == CBase::Get(lnk_fun_names[i_]))
			break;
	}

	return CBase::Error();
}

/////////////////////////////////////////////////////////////////////////////

static _pc_sz param_fun_names[] = {
	_T("glGetBooleanv"), _T("glGetFloatv"), _T("glGetIntegerv")
};

CParam:: CParam (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}
// https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glGet.xml ;
bool    CParam::GetBool (uint32_t _u_param_id) {
	_u_param_id;
	// GL_INVALID_ENUM : _u_param_id has unknown value;
	CBase::m_error << __METHOD__ << __s_ok;

	uint32_t u_result = 0;

	pfn_GetBool p_fun = reinterpret_cast<pfn_GetBool>(CBase::Get(param_fun_names[0]));
	if (nullptr == p_fun) { // the error is set by parent class;
		return !!u_result;
	}

	p_fun(_u_param_id, &u_result);

	return !!u_result;
}

float   CParam::GetFloat (uint32_t _u_param_id) {
	_u_param_id;
	// GL_INVALID_ENUM : _u_param_id has unknown value;
	CBase::m_error << __METHOD__ << __s_ok;

	float f_result = 0.0f;

	pfn_GetFloat p_fun = reinterpret_cast<pfn_GetFloat>(CBase::Get(param_fun_names[1]));
	if (nullptr == p_fun) {
		return f_result;
	}

	p_fun(_u_param_id, &f_result);

	return f_result;
}

int32_t CParam::GetInt (uint32_t _u_param_id) {
	_u_param_id;
	// GL_INVALID_ENUM : _u_param_id has unknown value;
	CBase::m_error << __METHOD__ << __s_ok;

	int32_t n_result = 0;

	pfn_GetFInt p_fun = reinterpret_cast<pfn_GetFInt>(CBase::Get(param_fun_names[2]));
	if (nullptr == p_fun) {
		return n_result;
	}

	p_fun(_u_param_id, &n_result);

	switch (CErr_ex().Get_last(false)) {
	case GL_INVALID_ENUM: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_enum: '_u_param_id' (%u) is invalid;"), _u_param_id);
	default:;
	}

	return n_result;
}

/////////////////////////////////////////////////////////////////////////////

#define GL_COMPILE_STATUS        0x8B81 // from glcorearb.h ;
#define GL_INFO_LOG_LENGTH       0x8B84 // from glcorearb.h ;
#define GL_SHADER_SOURCE_LENGTH  0x8B88 // from glcorearb.h ;

#define __err_no_support DXGI_ERROR_UNSUPPORTED

static _pc_sz shader_fun_names[] = {
	  _T("glCreateShader"),  _T("glDeleteShader"),  _T("glGetShaderInfoLog"),  _T("glGetShaderiv"), _T("glIsShader"), _T("glShaderSource")
};
enum class e_shader_fun_ndx : uint32_t {
	e_create = 0, e_delete = 1, e_infolog = 2, e_params = 3, e_is_shader = 4, e_source = 5,
};

CShader:: CShader (void) : CBase() { CString cs_cls = TString().Format(_T("%s::%s"), CBase::m_error.Class(), (_pc_sz)__CLASS__);
	CBase::m_error.Class(cs_cls, false);
}

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml ;
uint32_t  CShader::Create  (uint32_t _u_type) {
	_u_type;
	/* Possible errors:
		the retult is 0 : an error occurs creating the shader object; it very looks like a call to glGetShaderInfoLog() must be made for getting error desc ;
		GL_INVALID_ENUM : is not an accepted value ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	static const uint32_t n_err_result = 0;

	uint32_t n_result = n_err_result;

	pfn_Create p_fun = reinterpret_cast<pfn_Create>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_create]));
	if (nullptr == p_fun) // the error object is set by parent class 'CBase';
		return n_result;

	n_result = p_fun(_u_type);

	return n_result;
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml ;
err_code  CShader::Delete  (uint32_t _shader_id) {
	_shader_id;
	// GL_INVALID_VALUE : _shader_id is not a value generated by OpenGL ;
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Delete p_fun = reinterpret_cast<pfn_Delete>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_delete]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id);

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml ;
err_code  CShader::InfoLog (uint32_t _shader_id, int32_t _n_max_length, int32_t* _p_log_len, char* _p_log) {
	_shader_id; _n_max_length; _p_log_len; _p_log;
	/* Possible errors:
		GL_INVALID_VALUE     : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
		GL_INVALID_VALUE     : _n_max_length is less than 0 ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_InfoLog p_fun = reinterpret_cast<pfn_InfoLog>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_infolog]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id, _n_max_length, _p_log_len, _p_log);

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glIsShader.xml ;
bool   CShader::Is_valid  (uint32_t _shader_id) {
	_shader_id;
	// no error is generated if _shader_id is not a valid shader object identifier ;
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_IsValid p_fun = reinterpret_cast<pfn_IsValid>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_is_shader]));
	if (nullptr == p_fun) {
		return false;
	}

	const uint32_t b_result = !!p_fun(_shader_id);

	return b_result;
}
// https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glGetShaderiv.xml ;
err_code  CShader::Params  (uint32_t _shader_id, uint32_t _param_type, int32_t* _p_params) {
	_shader_id; _param_type; _p_params;
	CBase::m_error << __METHOD__ << __s_ok;
	/* Possible errors:
		GL_INVALID_ENUM : _param_type is not an accepted value ;
		GL_INVALID_VALUE : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_OPERATION : _param_type is GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, or GL_SHADER_SOURCE_LENGTH, but a shader compiler is not supported ;
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
	*/
	pfn_Params p_fun = reinterpret_cast<pfn_Params>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_params]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id, _param_type, _p_params);
	
	switch (CError_ex().Get_last(false)) {
	case GL_INVALID_ENUM : { CBase::m_error << (err_code)TErrCodes::eData::eNotFound = TString().Format(_T("_param_type (%u) is invalid"), _param_type); } break;
	case GL_INVALID_VALUE : { CBase::m_error << (err_code)TErrCodes::eData::eInvalid = TString().Format(_T("_shader_id (%u) is invalid"), _shader_id); } break;
	case GL_INVALID_OPERATION : {
		if (false) {}
		else if (GL_COMPILE_STATUS == _param_type) { CBase::m_error << __err_no_support = TString().Format(_T("No support for compiler: __compile_status (0x%04%x) #na"), _param_type); }
		else if (GL_INFO_LOG_LENGTH == _param_type) { CBase::m_error << __err_no_support = TString().Format(_T("No support for compiler: __info_log_len (0x%04%x) #na"), _param_type); }
		else if (GL_SHADER_SOURCE_LENGTH == _param_type) { CBase::m_error << __err_no_support = TString().Format(_T("No support for compiler: __shader_src_len (0x%04%x) #na"), _param_type); }
		else {
			CBase::m_error << __e_inv_arg = TString().Format(_T("_shader_id (%u) refers to no shader"), _shader_id); } break;
		}
	default:;
	}

	return CBase::Error();
}
// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml ;
err_code  CShader::Source  (uint32_t _shader_id, int32_t _n_count, const char** const _p_string, const int32_t* _p_length) {
	_shader_id; _n_count; _p_string; _p_length;
	/* Possible errors:
		GL_INVALID_OPERATION : _shader_id does not refer to a shader object ;
		GL_INVALID_VALUE     : _shader_id is not a value generated by OpenGL ;
		GL_INVALID_VALUE     : _n_count is less than 0 ;
	*/
	CBase::m_error << __METHOD__ << __s_ok;

	pfn_Source p_fun = reinterpret_cast<pfn_Source>(CBase::Get(shader_fun_names[(uint32_t)e_shader_fun_ndx::e_source]));
	if (nullptr == p_fun)
		return CBase::Error();

	p_fun(_shader_id, _n_count, _p_string, _p_length);

	switch (CErr_ex().Get_last(false)){
	case GL_INVALID_OPERATION: CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_oper: '_shader_id'(%u) refers to not shader object;"), _shader_id); break;
	case GL_INVALID_VALUE: {
			if (0 > _n_count)
			     CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_arg: '_n_count'(%d) cannot be negative;"), _n_count);
			else CBase::m_error << __e_inv_arg = TString().Format(_T("#__e_inv_arg: '_shader_id'(%u) is invalid;"), _shader_id);
		} break;
	default:;
	}
	return CBase::Error();
}

err_code CShader::Get_all (void) {
	CBase::m_error << __METHOD__ << __s_ok;

	for (uint32_t i_ = 0; i_ < _countof(shader_fun_names); i_++) {
		if (nullptr == CBase::Get(shader_fun_names[i_]))
			break;
	}

	return CBase::Error();
}